function [k,C] = DBSCAN(D,eps,MinPts)
%**************************************************************************
%**************************************************************************
%**************************************************************************
%函数功能：1.输入需要聚类的二维数据集，然后根据输入的阈值，采用密度聚类对数据集
%            进行密度聚类。
%输入：数据集D，e邻域的距离阈值eps,核心对象至少包含的样本数MinPts
%     其中，1）D为2×m的二维矩阵，2为二维矩阵的行数，m为二维矩阵的列数
%              输入的第i个2×m的二维矩阵表示为：
%              D[:,i]=|xi|
%                     |yi|
%              x,y分别为笛卡尔坐标系中的横纵坐标
%           2）eps为1×1的数值，代表e邻域的距离阈值eps
%           3）MinPts为1×1的数值，代表核心对象至少包含的样本数
%输出：数据集C,和聚类的簇个数k
%     其中，1）C为n×n的元组，C{i,j}代表聚类结果得到的某个簇（有可能为空簇），
%              令tempC=C{i,j},则tempC是一个包含该簇所有样本的元组。
%           2）k为1×1的数值，代表密度聚类后得到的簇个数
%作者（来源）：CSDN博客，链接为https://blog.csdn.net/qq_23968185/article/details/52303144
%联系方式：
%时间：
%**************************************************************************
%**************************************************************************
%**************************************************************************

%D = rand(2, 30);                       %样本集

% eps = 3;                            %邻域参数
% MinPts =2;                            %领域参数
O = zeros(1, size(D, 2));              %核心对象集
C = cell(size(D,2));

d = zeros(size(D, 2), size(D, 2));     %样本之间的距离大于eps元素值为1，反之0
for i = 1:size(D, 2)
    for j = size(D, 2):-1:i
        if pdist(D(:, [i j])') <= eps
            d(i, j) = 1;
        end
        d(j, i) = d(i, j);
    end
    %d(i,i) = 0;
    if sum(d(i, :)) >= MinPts
            O(i) = i;
    end
end

k =  0;                                %初始化聚类簇数
Tau = 1:size(D, 2);                    %初始化未访问样本集合
while sum(O) ~= 0
    Tau_old = Tau;                     %记录当前未访问样本集合

    %随机选取一个核心对象j,找出其密度可达点
    j = 1;
    while O(j) == 0%判断是否为核心对象，0则为核心对象
        j = j+1;
    end

    %ob = O(j);
    Q = zeros(1, size(Tau, 2));
    Q(j) = j;                          %将核心对象j加入队列Q
    Tau(j) = 0;                        %将核心对象j移出Tau

    while sum(Q) ~= 0

        %取出Q中首个样本m
        m = 1;
        while Q(m) == 0
            m = m+1;
        end
        Q(m) = 0;

        if sum(d(m,:)) >= MinPts
            for l = 1:size(d, 2)
                if d(m, l) == 1 && Tau(l) ~= 0
                    Q(l) = l;
                    Tau(l) = 0;
                end
            end
        end

    end
    k = k+1;
    for i = 1:size(Tau, 2)
        if Tau(i) ~= 0
            Tau_old(i) = 0;
        end
        if Tau_old(i) ~= 0
            O(i) =0;
        end
    end
    C{k} = Tau_old;
end

for i = 1:k
    C{i} = find(C{i}~=0);
    C{i};
    D1 = D(:,C{i});
    scatter(D1(1,:),D1(2,:));
    hold on
end

